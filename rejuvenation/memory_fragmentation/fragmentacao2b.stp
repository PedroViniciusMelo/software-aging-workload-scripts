global alloc, fallback, fragmenting = 0, index = 0
global who[100]

probe kernel.trace("mm_page_alloc_extfrag"){	
	if(who[execname(),pid(),pexecname(),ppid(),uid()] == 0){
		if(index == 100){  //o vetor encheu
			index = 0
			imprime_valores()
			imprime_processos()
			delete who
			printf("\n\n>>> Vetor esvaziado\n\n,")
		}
		printf("Processo: %s(%d) / Pai: %s(%d) / UID: %d,", execname(),pid(),pexecname(),ppid(),uid())
		index++
	}
	who[execname(),pid(),pexecname(),ppid(),uid()]++
	alloc = $alloc_order
	fallback = $fallback_order	
	if(fallback<alloc){
		fragmenting++
	}
}

function imprime_processos() {
	foreach([process,pid,pexecname,ppid,uid] in who){
		printf("\nProcesso: %s(%d) \t Pai: %s(%d) \t UID: %d \t Vezes: %d", process,pid,pexecname,ppid,uid,who[process,pid,pexecname,ppid,uid]);
	}
}

function imprime_valores() {
	if(index > 0){
		printf("\n%s\n", ctime(gettimeofday_s()));
		foreach([process,pid,pexecname,ppid,uid] in who){
		    printf("P%d: %d,", pid, who[process,pid,pexecname,ppid,uid]);
		}
	}
}

probe begin{
	printf(",");
}

//tempo a cada impressao dos valores
probe timer.s(30) {
    printf("\n\nProcessos: \n\n");
	imprime_processos();
	printf("\n\nValores dos processos: \n\n");
	imprime_valores();
	printf("Ocorrencia: %d", fragmenting);
}

probe end{
	printf("\n\nProcessos: \n\n");
    imprime_processos();
    printf("\n\nValores dos processos: \n\n");
    imprime_valores();
    printf("Ocorrencia: %d", fragmenting);
}

